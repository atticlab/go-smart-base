package main

import (
	"crypto/hmac"
	"crypto/rand"
	"crypto/sha256"
	"crypto/sha512"
	"encoding/binary"
	"encoding/hex"
	"fmt"
	"math/big"

	"github.com/btcsuite/btcd/btcec"
	"github.com/btcsuite/btcutil/base58"
	"golang.org/x/crypto/ripemd160"
)

const (
	HardenedKeyIndex uint32 = 2147483648
)

type ExtendedKey struct {
	Version           []byte
	Depth             byte
	ParentFingerPrint []byte //first 32 bits of RIPEMD(SHA256(parentPub))
	ChildNumber       uint32
	Chaincode         []byte
	PrivateKey        []byte
}

type ExtendedPublicKey struct {
	X                 []byte
	Y                 []byte
	Version           []byte
	Depth             byte
	ParentFingerPrint []byte //first 32 bits of RIPEMD(SHA256(parentPub))
	ChildNumber       uint32
	Chaincode         []byte
	PublicKey         []byte
}

func NewExtendedKey(Depth byte, ParentFingerPrint []byte, ChildNumber uint32, Chaincode []byte, PrivateKey []byte) *ExtendedKey {
	version := []byte{0x04, 0x88, 0xAD, 0xE4}
	return &ExtendedKey{version, Depth, ParentFingerPrint, ChildNumber, Chaincode, PrivateKey}
}

func NewExtendedPublicKey(X []byte, Y []byte, Depth byte, ParentFingerPrint []byte, ChildNumber uint32, Chaincode []byte, PublicKey []byte) *ExtendedPublicKey {
	version := []byte{0x04, 0x88, 0xB2, 0x1E}
	return &ExtendedPublicKey{X, Y, version, Depth, ParentFingerPrint, ChildNumber, Chaincode, PublicKey}
}

func Point(p []byte) ([]byte, []byte) {
	x, y := btcec.S256().ScalarBaseMult(p)
	return x.Bytes(), y.Bytes()
}

//Extended keys can be identified by the Hash160 (RIPEMD160 after SHA256)
//of the serialized ECSDA public key K, ignoring the chain code
//The first 32 bits of the identifier are called the key fingerprint.
func (ek *ExtendedKey) GetFingerPrint() []byte {
	_, publicKey := btcec.PrivKeyFromBytes(btcec.S256(), ek.PrivateKey)
	sha_256 := sha256.New()
	sha_256.Write(publicKey.SerializeCompressed())
	sha := sha_256.Sum(nil)
	ripemd := ripemd160.New()
	ripemd.Write(sha)
	final := ripemd.Sum(nil)

	return final[:4]
}

//Extended keys can be identified by the Hash160 (RIPEMD160 after SHA256)
//of the serialized ECSDA public key K, ignoring the chain code
//The first 32 bits of the identifier are called the key fingerprint.
func (pek *ExtendedPublicKey) GetFingerPrint() []byte {
	sha_256 := sha256.New()
	sha_256.Write(pek.PublicKey)
	sha := sha_256.Sum(nil)
	ripemd := ripemd160.New()
	ripemd.Write(sha)
	final := ripemd.Sum(nil)

	return final[:4]
}

//Private parent key to private child key derivation
func (ek *ExtendedKey) CKDpriv(index uint32) (*ExtendedKey, error) {
	if index >= HardenedKeyIndex {
		return ek.HCKDpriv(index)
	} else {
		return ek.NCKDpriv(index)
	}
}

//Hardened child key derivation (private key parent and child)
func (parent *ExtendedKey) HCKDpriv(index uint32) (*ExtendedKey, error) {
	//update w errors
	if len(parent.PrivateKey) != 32 {
		return nil, nil
	}
	//update w errors
	if len(parent.Chaincode) != 32 {
		return nil, nil
	}
	data := make([]byte, 37)
	copy(data[1:], parent.PrivateKey)
	binary.BigEndian.PutUint32(data[33:], index)
	hmac512 := hmac.New(sha512.New, parent.Chaincode)
	hmac512.Write(data)
	raw := hmac512.Sum(nil)
	//child Chaincode is the right 32 bytes of the result
	childChaincode := raw[32:]
	// child Private Key = parse256(left 32 bits) + parent key (mod n)
	// where n is the order of the curve
	// n is defined here on page 13: http://www.secg.org/sec2-v2.pdf
	leftInt := new(big.Int).SetBytes(raw[:32])
	parentKeyInt := new(big.Int).SetBytes(parent.PrivateKey)
	leftInt.Add(leftInt, parentKeyInt)
	leftInt.Mod(leftInt, btcec.S256().N)
	ParentFingerPrint := parent.GetFingerPrint()
	depthBytes := []byte{parent.Depth}
	depthInt := new(big.Int).SetBytes(depthBytes)
	depthInt.Add(depthInt, big.NewInt(1))
	depth := depthInt.Bytes()
	childExtendedKey := NewExtendedKey(depth[len(depth)-1], ParentFingerPrint, index, childChaincode, leftInt.Bytes())

	return childExtendedKey, nil
}

//Normal child key derivation (private key parent and child)
func (parent *ExtendedKey) NCKDpriv(index uint32) (*ExtendedKey, error) {
	data := make([]byte, 37)
	copy(data[0:], parent.GetPublicKey().PublicKey)
	binary.BigEndian.PutUint32(data[33:], index)
	hmac512 := hmac.New(sha512.New, parent.Chaincode)
	hmac512.Write(data)
	raw := hmac512.Sum(nil)
	//child Chaincode is the right 32 bytes of the result
	childChaincode := raw[32:]
	// child Private Key = parse256(left 32 bits) + parent key (mod n)
	// where n is the order of the curve
	// n is defined here on page 13: http://www.secg.org/sec2-v2.pdf
	leftInt := new(big.Int).SetBytes(raw[:32])
	parentKeyInt := new(big.Int).SetBytes(parent.PrivateKey)
	leftInt.Add(leftInt, parentKeyInt)
	leftInt.Mod(leftInt, btcec.S256().N)
	ParentFingerPrint := parent.GetFingerPrint()
	depthBytes := []byte{parent.Depth}
	depthInt := new(big.Int).SetBytes(depthBytes)
	depthInt.Add(depthInt, big.NewInt(1))
	depth := depthInt.Bytes()
	childExtendedKey := NewExtendedKey(depth[len(depth)-1], ParentFingerPrint, index, childChaincode, leftInt.Bytes())

	return childExtendedKey, nil
}

//Deriving Child public Key from Public Parent Key
func (parent *ExtendedPublicKey) CKDpub(index uint32) (*ExtendedPublicKey, error) {
	if index >= HardenedKeyIndex {
		return nil, nil
	}
	// let I = HMAC-SHA512(Key = cpar, Data = serP(Kpar) || ser32(i)).
	//serP(P): serializes the coordinate pair P = (x,y) as a byte sequence using SEC1's
	//compressed form: (0x02 or 0x03) || ser256(x)  <-- done above
	//, where the header byte depends on the parity of the omitted y coordinate.
	data := make([]byte, 37)
	copy(data[0:], parent.PublicKey)
	binary.BigEndian.PutUint32(data[33:], index)
	hmac512 := hmac.New(sha512.New, parent.Chaincode)
	hmac512.Write(data)
	raw := hmac512.Sum(nil)
	//child Chaincode is the right 32 bytes of the result
	childChaincode := raw[32:]
	// The returned child key Ki is point(parse256(IL)) + Kpar
	leftX, leftY := Point(raw[:32])
	x1 := new(big.Int).SetBytes(leftX)
	y1 := new(big.Int).SetBytes(leftY)
	x2 := new(big.Int).SetBytes(parent.X)
	y2 := new(big.Int).SetBytes(parent.Y)
	childX, childY := btcec.S256().Add(x1, y1, x2, y2)
	ParentFingerPrint := parent.GetFingerPrint()
	depthBytes := []byte{parent.Depth}
	depthInt := new(big.Int).SetBytes(depthBytes)
	depthInt.Add(depthInt, big.NewInt(1))
	depth := depthInt.Bytes()
	publicKey := btcec.PublicKey{Curve: btcec.S256(), X: childX, Y: childY}
	childExtendedPublicKey := NewExtendedPublicKey(childX.Bytes(), childY.Bytes(), depth[len(depth)-1], ParentFingerPrint, index, childChaincode, publicKey.SerializeCompressed())

	return childExtendedPublicKey, nil
}

//Generates child public key from parent private key
func (ek *ExtendedKey) CKDpub(index uint32) (*ExtendedPublicKey, error) {
	childPrivateKey, _ := ek.CKDpriv(index)
	chaincode := childPrivateKey.Chaincode

	_, publicKey := btcec.PrivKeyFromBytes(btcec.S256(), childPrivateKey.PrivateKey)
	childExtendedPublicKey := NewExtendedPublicKey(publicKey.X.Bytes(), publicKey.Y.Bytes(), childPrivateKey.Depth, childPrivateKey.ParentFingerPrint, index, chaincode, publicKey.SerializeCompressed())

	return childExtendedPublicKey, nil
}

func (ek *ExtendedKey) Serialize() {
	serialized := make([]byte, 78)
	//4 byte: version bytes (mainnet: 0x0488B21E public, 0x0488ADE4 private; testnet: 0x043587CF public, 0x04358394 private)
	copy(serialized[0:], ek.Version)
	//1 byte: depth: 0x00 for master nodes, 0x01 for level-1 derived keys, ....
	serialized[4] = ek.Depth
	//4 bytes: the fingerprint of the parent's key (0x00000000 if master key)
	copy(serialized[5:], ek.ParentFingerPrint)
	//4 bytes: child number. This is ser32(i) for i in xi = xpar/i, with xi the key being serialized. (0x00000000 if master key)
	binary.BigEndian.PutUint32(serialized[9:], ek.ChildNumber)
	//32 bytes: the chain code
	copy(serialized[13:], ek.Chaincode)
	//33 bytes:  0x00 || ser256(k) for private keys
	serialized[45] = 0x00
	copy(serialized[46:], ek.PrivateKey)
	//add 32 checksum bits (derived from the double SHA-256 checksum)
	firstSha256 := sha256.New()
	firstSha256.Write(serialized)
	one := firstSha256.Sum(nil)
	secondSha256 := sha256.New()
	secondSha256.Write(one)
	checksum := secondSha256.Sum(nil)[:4]
	serializedChecksum := make([]byte, 82)
	copy(serializedChecksum[0:], serialized)
	copy(serializedChecksum[78:], checksum)
	//convert to the Base58 representation
	buf := base58.Encode(serializedChecksum)

	fmt.Println(buf)
}

func (ek *ExtendedPublicKey) Serialize() {
	serialized := make([]byte, 78)
	//4 byte: version bytes (mainnet: 0x0488B21E public, 0x0488ADE4 private; testnet: 0x043587CF public, 0x04358394 private)
	copy(serialized[0:], ek.Version)
	//1 byte: depth: 0x00 for master nodes, 0x01 for level-1 derived keys, ....
	serialized[4] = ek.Depth
	//4 bytes: the fingerprint of the parent's key (0x00000000 if master key)
	copy(serialized[5:], ek.ParentFingerPrint)
	//4 bytes: child number. This is ser32(i) for i in xi = xpar/i, with xi the key being serialized. (0x00000000 if master key)
	binary.BigEndian.PutUint32(serialized[9:], ek.ChildNumber)
	//32 bytes: the chain code
	copy(serialized[13:], ek.Chaincode)
	//33 bytes: serP(K) for public keys
	copy(serialized[45:], ek.PublicKey)
	//add 32 checksum bits (derived from the double SHA-256 checksum)
	firstSha256 := sha256.New()
	firstSha256.Write(serialized)
	one := firstSha256.Sum(nil)
	secondSha256 := sha256.New()
	secondSha256.Write(one)
	checksum := secondSha256.Sum(nil)[:4]
	serializedChecksum := make([]byte, 82)
	copy(serializedChecksum[0:], serialized)
	copy(serializedChecksum[78:], checksum)
	//convert to the Base58 representation
	buf := base58.Encode(serializedChecksum)

	fmt.Println(buf)
}

func (ek *ExtendedKey) GetPublicKey() *ExtendedPublicKey {
	_, publicKey := btcec.PrivKeyFromBytes(btcec.S256(), ek.PrivateKey)
	return NewExtendedPublicKey(publicKey.X.Bytes(), publicKey.Y.Bytes(), ek.Depth, ek.ParentFingerPrint, ek.ChildNumber, ek.Chaincode, publicKey.SerializeCompressed())
}

//Generate a seed byte sequence S of a chosen length (between 128 and 512 bits; 256 bits is advised) from a (P)RNG.
func GenerateSeed() ([]byte, error) {
	seed := make([]byte, 32)
	_, err := rand.Read(seed)
	if err != nil {
		return nil, err
	}

	return seed, nil
}

//Calculate I = HMAC-SHA512(Key = "Bitcoin seed", Data = S)
func GenerateMasterKey(seed []byte) (*ExtendedKey, *ExtendedPublicKey, error) {
	seedString := []byte("Bitcoin seed")
	hmac512 := hmac.New(sha512.New, seedString)
	hmac512.Write(seed)
	raw := hmac512.Sum(nil)
	ParentFingerPrint := []byte{0x00, 0x00, 0x00, 0x00}
	var depth byte
	depth = 0x00
	var childNumber uint32
	childNumber = 0
	_, publicKey := btcec.PrivKeyFromBytes(btcec.S256(), raw[:32])
	masterPrivateKey := NewExtendedKey(depth, ParentFingerPrint, childNumber, raw[32:], raw[:32])
	masterPublicKey := NewExtendedPublicKey(publicKey.X.Bytes(), publicKey.Y.Bytes(), depth, ParentFingerPrint, childNumber, raw[32:], publicKey.SerializeCompressed())

	return masterPrivateKey, masterPublicKey, nil
}

//Run the two test Vectors from https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki
func main() {
	fmt.Println("\nMaster (hex): 000102030405060708090a0b0c0d0e0")
	fmt.Println("\nChain m")
	seed, _ := hex.DecodeString("000102030405060708090a0b0c0d0e0f")
	test1_master, test1_masterPublic, _ := GenerateMasterKey(seed)
	test1_master.Serialize()
	test1_masterPublic.Serialize()
	fmt.Println("\nChain m/0h")
	test1_master_0h, _ := test1_master.CKDpriv(2147483648)
	test1_master_0h.GetPublicKey().Serialize()
	test1_master_0h.Serialize()
	fmt.Println("\nChain m/0h/1")
	test1_master_0h_1, _ := test1_master_0h.CKDpriv(1)
	test1_master_0h_1.GetPublicKey().Serialize()
	test1_master_0h_1.Serialize()
	fmt.Println("\nChain m/0h/1/2h")
	test1_master_0h_1_2h, _ := test1_master_0h_1.CKDpriv(2147483650)
	test1_master_0h_1_2h.GetPublicKey().Serialize()
	test1_master_0h_1_2h.Serialize()
	fmt.Println("\nChain m/0h/1/2h/2")
	test1_master_0h_1_2h_2, _ := test1_master_0h_1_2h.CKDpriv(2)
	test1_master_0h_1_2h_2.GetPublicKey().Serialize()
	test1_master_0h_1_2h_2.Serialize()
	fmt.Println("\nChain m/0H/1/2H/2/1000000000")
	test1_master_0h_1_2h_2_1000000000, _ := test1_master_0h_1_2h_2.CKDpriv(1000000000)
	test1_master_0h_1_2h_2_1000000000.GetPublicKey().Serialize()
	test1_master_0h_1_2h_2_1000000000.Serialize()

	fmt.Println("\n\n Master (hex): fffcf9f6f3f0edeae7e4e1dedbd8d5d2cfccc9c6c3c0bdbab7b4b1aeaba8a5a29f9c999693908d8a8784817e7b7875726f6c696663605d5a5754514e4b484542")
	fmt.Println("\nChain m")
	seed2, _ := hex.DecodeString("fffcf9f6f3f0edeae7e4e1dedbd8d5d2cfccc9c6c3c0bdbab7b4b1aeaba8a5a29f9c999693908d8a8784817e7b7875726f6c696663605d5a5754514e4b484542")
	test2_master, test2_masterPublic, _ := GenerateMasterKey(seed2)
	test2_master.Serialize()
	test2_masterPublic.Serialize()
	fmt.Println("\nChain m/0")
	test2_master_0, _ := test2_master.CKDpriv(0)
	test2_master_0pub, _ := test2_masterPublic.CKDpub(0)
	test2_master_0.GetPublicKey().Serialize()
	fmt.Println("from public to public derivation:")
	test2_master_0pub.Serialize()
	test2_master_0.Serialize()
	fmt.Println("\nChain m/0/2147483647h")
	test2_master_0_2147483647h, _ := test2_master_0.CKDpriv(2147483647 + HardenedKeyIndex)
	test2_master_0_2147483647h.GetPublicKey().Serialize()
	test2_master_0_2147483647h.Serialize()
	fmt.Println("\nChain m/0/2147483647h/1")
	test2_master_0_2147483647h_1, _ := test2_master_0_2147483647h.CKDpriv(1)
	test2_master_0_2147483647h_1.GetPublicKey().Serialize()
	test2_master_0_2147483647h_1.Serialize()
	fmt.Println("\nChain m/0/2147483647h/1/2147483646h")
	test2_master_0_2147483647h_1_2147483646h, _ := test2_master_0_2147483647h_1.CKDpriv(2147483646 + HardenedKeyIndex)
	test2_master_0_2147483647h_1_2147483646h.GetPublicKey().Serialize()
	test2_master_0_2147483647h_1_2147483646h.Serialize()
	fmt.Println("\nChain m/0/2147483647h/1/2147483646h/2")
	test2_master_0_2147483647h_1_2147483646h_2, _ := test2_master_0_2147483647h_1_2147483646h.CKDpriv(2)
	test2_master_0_2147483647h_1_2147483646h_2.GetPublicKey().Serialize()
	test2_master_0_2147483647h_1_2147483646h_2.Serialize()
}
